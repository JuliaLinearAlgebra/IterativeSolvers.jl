<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Randomized algorithms · IterativeSolvers.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IterativeSolvers.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="getting_started.html">Getting started</a></li><li><a class="toctext" href="preconditioning.html">Preconditioning</a></li><li><span class="toctext">Linear systems</span><ul><li><a class="toctext" href="linear_systems/cg.html">Conjugate Gradients</a></li><li><a class="toctext" href="linear_systems/chebyshev.html">Chebyshev iteration</a></li><li><a class="toctext" href="linear_systems/minres.html">MINRES</a></li><li><a class="toctext" href="linear_systems/bicgstabl.html">BiCGStab(l)</a></li><li><a class="toctext" href="linear_systems/idrs.html">IDR(s)</a></li><li><a class="toctext" href="linear_systems/gmres.html">Restarted GMRES</a></li><li><a class="toctext" href="linear_systems/lsmr.html">LSMR</a></li><li><a class="toctext" href="linear_systems/lsqr.html">LSQR</a></li><li><a class="toctext" href="linear_systems/stationary.html">Stationary methods</a></li></ul></li><li><span class="toctext">Eigenproblems</span><ul><li><a class="toctext" href="eigenproblems/power_method.html">Power method</a></li></ul></li><li><a class="toctext" href="svd/svdl.html">SVDL</a></li><li class="current"><a class="toctext" href="randomized.html">Randomized algorithms</a><ul class="internal"><li><a class="toctext" href="#Condition-number-estimate-1">Condition number estimate</a></li><li><a class="toctext" href="#Extremal-eigenvalue-estimates-1">Extremal eigenvalue estimates</a></li><li><a class="toctext" href="#Norm-estimate-1">Norm estimate</a></li></ul></li><li><a class="toctext" href="iterators.html">The iterator approach</a></li><li><span class="toctext">About</span><ul><li><a class="toctext" href="about/CONTRIBUTING.html">Contributing</a></li><li><a class="toctext" href="about/license.html">License</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="randomized.html">Randomized algorithms</a></li></ul><a class="edit-page" href="https://github.com/JuliaMath/IterativeSolvers.jl/blob/master/docs/src/randomized.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Randomized algorithms</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Randomized-1" href="#Randomized-1">Randomized algorithms</a></h1><p>The methods below are based on <a href="#footnote-Halko2011">[Halko2011]</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeSolvers.reig" href="#IterativeSolvers.reig"><code>IterativeSolvers.reig</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">reig(A, l)</code></pre><p>Compute the spectral (<code>Eigen</code>) decomposition of <code>A</code> using a randomized algorithm.</p><p><strong>Arguments</strong></p><ul><li><p><code>A</code>: input matrix.</p></li><li><p><code>l::Int</code>: number of eigenpairs to find.</p></li></ul><p><strong>Output</strong></p><ul><li><p><code>::Base.LinAlg.Eigen</code>: eigen decomposition.</p></li></ul><p><strong>Implementation note</strong></p><p>This is a wrapper around <code>eigfact_onepass()</code> which uses the randomized samples found using <code>srft(l)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/IterativeSolvers.jl/blob/a7c0fb9a19dbccfadec87e4b1666b3a9c0092414/src/rsvd.jl#L503-L522">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeSolvers.rsvdfact" href="#IterativeSolvers.rsvdfact"><code>IterativeSolvers.rsvdfact</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rsvdfact(A, n, p=0)</code></pre><p>Compute partial singular value decomposition of <code>A</code> using a randomized algorithm.</p><p><strong>Arguments</strong></p><p><code>A</code>: input matrix.</p><p><code>n::Int</code>: number of singular value/vector pairs to find.</p><p><code>p::Int=0</code>: number of extra vectors to include in computation.</p><p><strong>Output</strong></p><p><code>::SVD</code>: singular value decomposition.</p><div class="admonition warning"><div class="admonition-title">Accuracy</div><div class="admonition-text"><p>This variant of the randomized singular value decomposition is the most commonly found implementation but is not recommended for accurate computations, as it often has trouble finding the <code>n</code> largest singular pairs, but rather finds <code>n</code> large singular pairs which may not necessarily be the largest.</p></div></div><p><strong>Implementation note</strong></p><p>This function calls <code>rrange</code>, which uses naive randomized rangefinding to compute a basis for a subspace of dimension <code>n</code> (Algorithm 4.1 of <a href="#footnote-Halko2011">[Halko2011]</a>), followed by <code>svdfact_restricted()</code>, which computes the exact SVD factorization on the restriction of <code>A</code> to this randomly selected subspace (Algorithm 5.1 of <a href="#footnote-Halko2011">[Halko2011]</a>).</p><p>Alternatively, you can mix and match your own randomized algorithm using any of the randomized range finding algorithms to find a suitable subspace and feeding the result to one of the routines that computes the <code>SVD</code> restricted to that subspace.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/IterativeSolvers.jl/blob/a7c0fb9a19dbccfadec87e4b1666b3a9c0092414/src/rsvd.jl#L13-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeSolvers.rsvd_fnkz" href="#IterativeSolvers.rsvd_fnkz"><code>IterativeSolvers.rsvd_fnkz</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rsvd_fnkz(A, k)</code></pre><p>Compute the randomized SVD by iterative refinement from randomly selected columns/rows <a href="#footnote-Friedland2006">[Friedland2006]</a>.</p><p><strong>Arguments</strong></p><ul><li><p><code>A</code>: matrix whose SVD is desired;</p></li><li><p><code>k::Int</code>: desired rank of approximation (<code>k ≤ min(m, n)</code>).</p></li></ul><p><strong>Keywords</strong></p><ul><li><p><code>l::Int = k</code>: number of columns/rows to sample at each iteration (<code>1 ≤ l ≤ k</code>);</p></li><li><p><code>N::Int = minimum(size(A))</code>: maximum number of iterations;</p></li><li><p><code>ϵ::Real = prod(size(A))*eps()</code>: relative threshold for convergence, as measured by growth of the spectral norm;</p></li><li><p><code>method::Symbol = :eig</code>: problem to solve.</p><ol><li><p><code>:eig</code>: eigenproblem.</p></li><li><p><code>:svd</code>: singular problem.</p></li></ol></li><li><p><code>verbose::Bool = false</code>: print convergence information at each iteration.</p></li></ul><p><strong>Return value</strong></p><p>SVD object of <code>rank ≤ k</code>.</p><div class="footnote" id="footnote-Friedland2006"><a href="#footnote-Friedland2006"><strong>[Friedland2006]</strong></a><p>Friedland, Shmuel, et al. &quot;Fast Monte-Carlo low rank approximations for  matrices.&quot; System of Systems Engineering, 2006 IEEE/SMC International  Conference on. IEEE, 2006.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/IterativeSolvers.jl/blob/a7c0fb9a19dbccfadec87e4b1666b3a9c0092414/src/rsvd_fnkz.jl#L11-L41">source</a></section><h2><a class="nav-anchor" id="Condition-number-estimate-1" href="#Condition-number-estimate-1">Condition number estimate</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeSolvers.rcond" href="#IterativeSolvers.rcond"><code>IterativeSolvers.rcond</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rcond(A, iters=1)</code></pre><p>Estimate matrix condition number randomly.</p><p><strong>Arguments</strong></p><ul><li><p><code>A</code>: matrix whose condition number to estimate. Must be square and</p></li></ul><p>support premultiply (<code>A*⋅</code>) and solve (<code>A\⋅</code>).</p><ul><li><p><code>iters::Int = 1</code>: number of power iterations to run.</p></li></ul><p><strong>Keywords</strong></p><ul><li><p><code>p::Real = 0.05</code>: probability that estimate fails to hold as an upper bound.</p></li></ul><p><strong>Output</strong></p><p>Interval <code>(x, y)</code> which contains <code>κ(A)</code> with probability <code>1 - p</code>.</p><p><strong>Implementation note</strong></p><p><a href="#footnote-Dixon1983">[Dixon1983]</a> originally describes this as a computation that can be done by computing the necessary number of power iterations given p and the desired accuracy parameter <code>θ=y/x</code>. However, these bounds were only derived under the assumptions of exact arithmetic. Empirically, <code>iters≥4</code> has been seen to result in incorrect results in that the computed interval does not contain the true condition number. This implemention therefore makes <code>iters</code> an explicitly user-controllable parameter from which to infer the accuracy parameter and hence the interval containing <code>κ(A)</code>. ```</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/IterativeSolvers.jl/blob/a7c0fb9a19dbccfadec87e4b1666b3a9c0092414/src/rlinalg.jl#L149-L179">source</a></section><h2><a class="nav-anchor" id="Extremal-eigenvalue-estimates-1" href="#Extremal-eigenvalue-estimates-1">Extremal eigenvalue estimates</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeSolvers.reigmin" href="#IterativeSolvers.reigmin"><code>IterativeSolvers.reigmin</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">reigmin(A, iters=1)</code></pre><p>Estimate minimal eigenvalue randomly.</p><p><strong>Arguments</strong></p><ul><li><p><code>A</code>: Matrix whose maximal eigenvalue to estimate.</p></li></ul><p>Must be square and support premultiply (<code>A*⋅</code>).</p><ul><li><p><code>iters::Int=1</code>: Number of power iterations to run. (Recommended: <code>iters</code> ≤ 3)</p></li></ul><p><strong>Keywords</strong></p><ul><li><p><code>p::Real=0.05</code>: Probability that estimate fails to hold as an upper bound.</p></li></ul><p><strong>Output</strong></p><p>Interval <code>(x, y)</code> which contains the maximal eigenvalue of <code>A</code> with probability <code>1 - p</code>.</p><p><strong>References</strong></p><p>Corollary of Theorem 1 in <a href="#footnote-Dixon1983">[Dixon1983]</a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/IterativeSolvers.jl/blob/a7c0fb9a19dbccfadec87e4b1666b3a9c0092414/src/rlinalg.jl#L234-L257">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeSolvers.reigmax" href="#IterativeSolvers.reigmax"><code>IterativeSolvers.reigmax</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">reigmax(A, iters=1)</code></pre><p>Estimate maximal eigenvalue randomly.</p><p><strong>Arguments</strong></p><ul><li><p><code>A</code>: Matrix whose maximal eigenvalue to estimate.</p></li></ul><p>Must be square and support premultiply (<code>A*⋅</code>).</p><ul><li><p><code>iters::Int=1</code>: Number of power iterations to run. (Recommended: <code>iters</code> ≤ 3)</p></li></ul><p><strong>Keywords</strong></p><ul><li><p><code>p::Real=0.05</code>: Probability that estimate fails to hold as an upper bound.</p></li></ul><p><strong>Output</strong></p><p>Interval <code>(x, y)</code> which contains the maximal eigenvalue of <code>A</code> with probability <code>1 - p</code>.</p><p><strong>References</strong></p><p>Corollary of Theorem 1 in <a href="#footnote-Dixon1983">[Dixon1983]</a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/IterativeSolvers.jl/blob/a7c0fb9a19dbccfadec87e4b1666b3a9c0092414/src/rlinalg.jl#L197-L220">source</a></section><h2><a class="nav-anchor" id="Norm-estimate-1" href="#Norm-estimate-1">Norm estimate</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeSolvers.rnorm" href="#IterativeSolvers.rnorm"><code>IterativeSolvers.rnorm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rnorm(A, mvps)</code></pre><p>Compute a probabilistic upper bound on the norm of a matrix <code>A</code>. <code>‖A‖ ≤ α √(2/π) maxᵢ ‖Aωᵢ‖</code> with probability <code>p=α^(-mvps)</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>A</code>: matrix whose norm to estimate.</p></li><li><p><code>mvps::Int</code>: number of matrix-vector products to compute.</p></li></ul><p><strong>Keywords</strong></p><ul><li><p><code>p::Real=0.05</code>: probability of upper bound failing.</p></li></ul><p><strong>Output</strong></p><p>Estimate of ‖A‖.</p><p>See also <a href="randomized.html#IterativeSolvers.rnorms"><code>rnorms</code></a> for a different estimator that uses  premultiplying by both <code>A</code> and <code>A&#39;</code>.</p><p><strong>References</strong></p><p>Lemma 4.1 of Halko2011</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/IterativeSolvers.jl/blob/a7c0fb9a19dbccfadec87e4b1666b3a9c0092414/src/rlinalg.jl#L62-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeSolvers.rnorms" href="#IterativeSolvers.rnorms"><code>IterativeSolvers.rnorms</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rnorms(A, iters=1)</code></pre><p>Estimate matrix norm randomly using <code>A&#39;A</code>.</p><p>Compute a probabilistic upper bound on the norm of a matrix <code>A</code>.</p><pre><code class="language-none">ρ = √(‖(A&#39;A)ʲω‖/‖(A&#39;A)ʲ⁻¹ω‖)</code></pre><p>which is an estimate of the spectral norm of <code>A</code> produced by <code>iters</code> steps of the power method starting with normalized <code>ω</code>, is a lower bound on the true norm by a factor</p><pre><code class="language-none">ρ ≤ α ‖A‖</code></pre><p>with probability greater than <code>1 - p</code>, where <code>p = 4\sqrt(n/(iters-1)) α^(-2iters)</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>A</code>: matrix whose norm to estimate.</p></li><li><p><code>iters::Int = 1</code>: mumber of power iterations to perform.</p></li></ul><p><strong>Keywords</strong></p><ul><li><p><code>p::Real = 0.05</code>: probability of upper bound failing.</p></li><li><p><code>At = A&#39;</code>: Transpose of <code>A</code>.</p></li></ul><p><strong>Output</strong></p><p>Estimate of ‖A‖.</p><p>See also <a href="randomized.html#IterativeSolvers.rnorm"><code>rnorm</code></a> for a different estimator that does not require premultiplying by <code>A&#39;</code></p><p><strong>References</strong></p><p>Appendix of <a href="#footnote-Liberty2007">[Liberty2007]</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/IterativeSolvers.jl/blob/a7c0fb9a19dbccfadec87e4b1666b3a9c0092414/src/rlinalg.jl#L98-L135">source</a></section><div class="footnote" id="footnote-Halko2011"><a href="#footnote-Halko2011"><strong>[Halko2011]</strong></a><p>Halko, Nathan, Per-Gunnar Martinsson, and Joel A. Tropp. &quot;Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions.&quot; SIAM review 53.2 (2011): 217-288.</p></div><div class="footnote" id="footnote-Dixon1983"><a href="#footnote-Dixon1983"><strong>[Dixon1983]</strong></a><p>Dixon, John D. &quot;Estimating extremal eigenvalues and condition numbers of matrices.&quot; SIAM Journal on Numerical Analysis 20.4 (1983): 812-814.</p></div><div class="footnote" id="footnote-Liberty2007"><a href="#footnote-Liberty2007"><strong>[Liberty2007]</strong></a><p>Liberty, Edo, et al. &quot;Randomized algorithms for the low-rank approximation of matrices.&quot; Proceedings of the National Academy of Sciences 104.51 (2007): 20167-20172.</p></div><footer><hr/><a class="previous" href="svd/svdl.html"><span class="direction">Previous</span><span class="title">SVDL</span></a><a class="next" href="iterators.html"><span class="direction">Next</span><span class="title">The iterator approach</span></a></footer></article></body></html>
