<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Power method · IterativeSolvers.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IterativeSolvers.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../getting_started/">Getting started</a></li><li><a class="toctext" href="../../preconditioning/">Preconditioning</a></li><li><span class="toctext">Linear systems</span><ul><li><a class="toctext" href="../../linear_systems/cg/">Conjugate Gradients</a></li><li><a class="toctext" href="../../linear_systems/chebyshev/">Chebyshev iteration</a></li><li><a class="toctext" href="../../linear_systems/minres/">MINRES</a></li><li><a class="toctext" href="../../linear_systems/bicgstabl/">BiCGStab(l)</a></li><li><a class="toctext" href="../../linear_systems/idrs/">IDR(s)</a></li><li><a class="toctext" href="../../linear_systems/gmres/">Restarted GMRES</a></li><li><a class="toctext" href="../../linear_systems/lsmr/">LSMR</a></li><li><a class="toctext" href="../../linear_systems/lsqr/">LSQR</a></li><li><a class="toctext" href="../../linear_systems/stationary/">Stationary methods</a></li></ul></li><li><span class="toctext">Eigenproblems</span><ul><li class="current"><a class="toctext" href>Power method</a><ul class="internal"><li><a class="toctext" href="#Usage-1">Usage</a></li><li><a class="toctext" href="#Implementation-details-1">Implementation details</a></li></ul></li><li><a class="toctext" href="../lobpcg/">LOBPCG</a></li></ul></li><li><a class="toctext" href="../../svd/svdl/">SVDL</a></li><li><a class="toctext" href="../../iterators/">The iterator approach</a></li><li><span class="toctext">About</span><ul><li><a class="toctext" href="../../about/CONTRIBUTING/">Contributing</a></li><li><a class="toctext" href="../../about/license/">License</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Eigenproblems</li><li><a href>Power method</a></li></ul><a class="edit-page" href="https://github.com/JuliaMath/IterativeSolvers.jl/blob/master/docs/src/eigenproblems/power_method.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Power method</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="PowerMethod-1" href="#PowerMethod-1">(Inverse) power method</a></h1><p>Solves the eigenproblem <span>$Ax = λx$</span> approximately where <span>$A$</span> is a general linear map. By default converges towards the dominant eigenpair <span>$(λ, x)$</span> such that <span>$|λ|$</span> is largest. Shift-and-invert can be applied to target a specific eigenvalue near <code>shift</code> in the complex plane.</p><h2><a class="nav-anchor" id="Usage-1" href="#Usage-1">Usage</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeSolvers.powm" href="#IterativeSolvers.powm"><code>IterativeSolvers.powm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">powm(B; kwargs...) -&gt; λ, x, [history]</code></pre><p>See <a href="#IterativeSolvers.powm!"><code>powm!</code></a>. Calls <code>powm!(B, x0; kwargs...)</code> with <code>x0</code> initialized as a random, complex unit vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/IterativeSolvers.jl/blob/bb9553cc696402d1dd2b6c024eb73696754bf180/src/simple.jl#L58-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeSolvers.powm!" href="#IterativeSolvers.powm!"><code>IterativeSolvers.powm!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">powm!(B, x; shift = zero(eltype(B)), inverse::Bool = false, kwargs...) -&gt; λ, x, [history]</code></pre><p>By default finds the approximate eigenpair <code>(λ, x)</code> of <code>B</code> where <code>|λ|</code> is largest.</p><p><strong>Arguments</strong></p><ul><li><code>B</code>: linear map, see the note below.</li><li><code>x</code>: normalized initial guess. Don&#39;t forget to use complex arithmetic when necessary.</li></ul><p><strong>Keywords</strong></p><ul><li><code>tol::Real = eps(real(eltype(B))) * size(B, 2) ^ 3</code>: stopping tolerance for the residual norm;</li><li><code>maxiter::Integer = size(B,2)</code>: maximum number of iterations;</li><li><code>log::Bool</code>: keep track of the residual norm in each iteration;</li><li><code>verbose::Bool</code>: print convergence information during the iterations.</li></ul><div class="admonition note"><div class="admonition-title">Shift-and-invert</div><div class="admonition-text"><p>When applying shift-and-invert to <span>$Ax = λx$</span> with <code>invert = true</code> and <code>shift = ...</code>, note that the role of <code>B * b</code> becomes computing <code>inv(A - shift I) * b</code>. So rather than passing the linear map <span>$A$</span> itself, pass a linear map <code>B</code> that has the action of shift-and-invert. The eigenvalue is transformed back to an eigenvalue of the actual matrix <span>$A$</span>.</p></div></div><p><strong>Return values</strong></p><p><strong>if <code>log</code> is <code>false</code></strong></p><ul><li><code>λ::Number</code> approximate eigenvalue computed as the Rayleigh quotient;</li><li><code>x::Vector</code> approximate eigenvector.</li></ul><p><strong>if <code>log</code> is <code>true</code></strong></p><ul><li><code>λ::Number</code>: approximate eigenvalue computed as the Rayleigh quotient;</li><li><code>x::Vector</code>: approximate eigenvector;</li><li><code>history</code>: convergence history.</li></ul><p><strong>ConvergenceHistory keys</strong></p><ul><li><code>:tol</code> =&gt; <code>::Real</code>: stopping tolerance;</li><li><code>:resnom</code> =&gt; <code>::Vector</code>: residual norm at each iteration.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using LinearMaps
σ = 1.0 + 1.3im
A = rand(ComplexF64, 50, 50)
F = lu(A - σ * I)
Fmap = LinearMap{ComplexF64}((y, x) -&gt; ldiv!(y, F, x), 50, ismutating = true)
λ, x = powm(Fmap, inverse = true, shift = σ, tol = 1e-4, maxiter = 200)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/IterativeSolvers.jl/blob/bb9553cc696402d1dd2b6c024eb73696754bf180/src/simple.jl#L70-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeSolvers.invpowm" href="#IterativeSolvers.invpowm"><code>IterativeSolvers.invpowm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">invpowm(B; shift = σ, kwargs...) -&gt; λ, x, [history]</code></pre><p>Find the approximate eigenpair <code>(λ, x)</code> of <span>$A$</span> near <code>shift</code>, where <code>B</code> is a linear map that has the effect <code>B * v = inv(A - σI) * v</code>.</p><p>The method calls <code>powm!(B, x0; inverse = true, shift = σ)</code> with <code>x0</code> a random, complex unit vector. See <a href="#IterativeSolvers.powm!"><code>powm!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">using LinearMaps
σ = 1.0 + 1.3im
A = rand(ComplexF64, 50, 50)
F = lu(A - σ * I)
Fmap = LinearMap{ComplexF64}((y, x) -&gt; ldiv!(y, F, x), 50, ismutating = true)
λ, x = invpowm(Fmap, shift = σ, tol = 1e-4, maxiter = 200)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/IterativeSolvers.jl/blob/bb9553cc696402d1dd2b6c024eb73696754bf180/src/simple.jl#L151-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeSolvers.invpowm!" href="#IterativeSolvers.invpowm!"><code>IterativeSolvers.invpowm!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">invpowm!(B, x0; shift = σ, kwargs...) -&gt; λ, x, [history]</code></pre><p>Find the approximate eigenpair <code>(λ, x)</code> of <span>$A$</span> near <code>shift</code>, where <code>B</code> is a linear map that has the effect <code>B * v = inv(A - σI) * v</code>.</p><p>The method calls <code>powm!(B, x0; inverse = true, shift = σ)</code>. See <a href="#IterativeSolvers.powm!"><code>powm!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/IterativeSolvers.jl/blob/bb9553cc696402d1dd2b6c024eb73696754bf180/src/simple.jl#L177-L184">source</a></section><h2><a class="nav-anchor" id="Implementation-details-1" href="#Implementation-details-1">Implementation details</a></h2><p>Storage requirements are 3 vectors: the approximate eigenvector <code>x</code>, the residual vector <code>r</code> and a temporary. The residual norm lags behind one iteration, as it is computed when <span>$Ax$</span> is performed. Therefore the final resdiual norm is even smaller.</p><footer><hr/><a class="previous" href="../../linear_systems/stationary/"><span class="direction">Previous</span><span class="title">Stationary methods</span></a><a class="next" href="../lobpcg/"><span class="direction">Next</span><span class="title">LOBPCG</span></a></footer></article></body></html>
